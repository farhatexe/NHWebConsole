<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpx.Core</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.BS.GetHashCode">
<summary>
 Gets the hash code for the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.System-Collections-Generic-IEnumerable`1-GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.GetEnumerator">
<summary>
 Gets an enumerator for the bytes stored in the byte string.
</summary>
</member>
<member name="M:FSharpx.BS.Equals(System.Object)">
<summary>
 Compares two objects for equality. When both are byte strings, structural equality is used.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.BS.Compare(FSharpx.BS,FSharpx.BS)">
<summary>
 Compares two byte strings based on their structure.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.BS">
<summary>
 An ArraySegment with structural comparison and equality.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DList`1">
<summary>
 The DList is an implementation of John Hughes&apos; append list.
 See http://dl.acm.org/citation.cfm?id=8475 for more information.
 This implementation adds an additional parameter to allow a more
 efficient calculation of the list length.
 Note that an alternate form would represent the DList as:
 type DList&lt;&apos;a&gt; = DList of (&apos;a list -&gt; &apos;a list)
 An example can be found at http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5327209#5327209
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``3(System.Func{``0,``1,``2})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``2(System.Func{``0,``1})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``1(System.Func{``0})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``3(System.Action{``0,``1,``2})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``2(System.Action{``0,``1})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``1(System.Action{``0})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction(System.Action)">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="T:FSharpx.FSharpFunc">
 <summary>
 Conversion functions from Action/Func to FSharpFunc
 We need these because FuncConvert often makes C# type inference fail.
 </summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Funcs">
<summary>
 Extensions around Actions and Funcs
</summary>
</member>
<member name="M:FSharpx.L.F``3(System.Func{``0,``1,``2})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``2(System.Func{``0,``1})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``1(System.Func{``0})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="T:FSharpx.L">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.ArrayModule">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterDot``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequentially compose two async actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiply``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_MultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Async.ap``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Async">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.ByteString.append(FSharpx.BS,FSharpx.BS)">
<summary>
 append uses Buffer.BlockCopy for efficient array operations.
 Please note that a new array is created and both arrays are copied in,
 disregarding any additional bytes in the original, underlying arrays.
</summary>
</member>
<member name="M:FSharpx.ByteString.cons(System.Byte,FSharpx.BS)">
<summary>
 cons uses Buffer.SetByte and Buffer.BlockCopy for efficient array operations.
 Please note that a new array is created and both the head and tail are copied in,
 disregarding any additional bytes in the original tail array.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.ByteString.|BS|(FSharpx.BS)">
<summary>
 An active pattern for conveniently retrieving the properties of a BS.
</summary>
</member>
<member name="T:FSharpx.ByteString">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Choice.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpChoice{``3,``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequentially compose two either actions, discarding any value produced by the first
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Choice.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Choice.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Choice.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``2},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Choice">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Continuation.Coroutine">
<summary>
 The coroutine type from http://fssnip.net/7M
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Continuation.Cont`2">
<summary>
 The continuation monad.
 The algorithm is from Wes Dyer http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
 Current implementation from Matt&apos;s gist at https://gist.github.com/628956
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Continuation.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Continuation.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``3,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Continuation.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequentially compose two continuation actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Continuation.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Continuation.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``2,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Continuation.ap``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},``1},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``1},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Continuation.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.FSharpFunc`2{System.Exception,``2},``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Continuation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.DList.fold``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,FSharpx.DList{``1})">
<summary>
 Fold walks the DList using constant stack space. Implementation is from Norman Ramsey.
 See http://stackoverflow.com/questions/5324623/functional-o1-append-and-on-iteration-from-first-element-list-data-structure/5334068#5334068
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.DList">

</member>
<member name="">

</member>
<member name="T:FSharpx.DictionaryModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Distribution">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Enumerator.scanUntil``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state until the provided predicate is true.
</summary>
</member>
<member name="M:FSharpx.Enumerator.scanWhile``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state while the provided predicate is true.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Enumerator.scan``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``0}},``0,System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Enumerator">

</member>
<member name="M:FSharpx.IO.combinePaths(System.String,System.String)">
<summary>
 Combines two path strings
</summary>
</member>
<member name="P:FSharpx.IO.directorySeparator">
<summary>
 The directory separator string. On most systems / or \
</summary>
</member>
<member name="M:FSharpx.IO.appendFileNamesIfNotNull(System.Collections.Generic.IEnumerable{System.String},System.Text.StringBuilder)">
<summary>
 Appends all notnull fileNames
</summary>
</member>
<member name="M:FSharpx.IO.appendStringIfValueIsNotNullOrEmpty(System.String)">
<summary>
 Appends a text if the value is not null or empty
</summary>
</member>
<member name="M:FSharpx.IO.appendStringIfValueIsNotNull``1(``0)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.appendIfNotNull``1(``0,System.String)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.appendIfFalse(System.Boolean)">
<summary>
 Appends a text if the predicate is false
</summary>
</member>
<member name="M:FSharpx.IO.appendIfTrue(System.Boolean,System.String,System.Text.StringBuilder)">
<summary>
 Appends a text if the predicate is true
</summary>
</member>
<member name="M:FSharpx.IO.append(System.String,System.Text.StringBuilder)">
<summary>
 Appends a text
</summary>
</member>
<member name="M:FSharpx.IO.convertTextToWindowsLineBreaks(System.String)">
<summary>
 Converts the given text from linux or mac linebreaks to windows line breaks
</summary>
</member>
<member name="M:FSharpx.IO.replaceFile(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Replaces the file with the given string
</summary>
</member>
<member name="M:FSharpx.IO.writeStringToFile(System.Boolean,System.String,System.String)">
<summary>
 Writes a single string to a file
</summary>
</member>
<member name="M:FSharpx.IO.writeToFile(System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Writes a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.readFile(System.String)">
<summary>
 Reads a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.readFileAsString(System.String)">
<summary>
 Reads a file as one text
</summary>
</member>
<member name="M:FSharpx.IO.allFilesExist(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks if all given files exists
</summary>
</member>
<member name="M:FSharpx.IO.checkFileExists(System.String)">
<summary>
 Checks if the file exists on disk.
</summary>
</member>
<member name="P:FSharpx.IO.currentDirectory">
<summary>
 Gets the current directory
</summary>
</member>
<member name="M:FSharpx.IO.filesInDir(System.IO.DirectoryInfo)">
<summary>
 Gets all files in the directory
</summary>
</member>
<member name="M:FSharpx.IO.subDirectories(System.IO.DirectoryInfo)">
<summary>
 Gets all subdirectories
</summary>
</member>
<member name="M:FSharpx.IO.getFullName(System.String)">
<summary>
 Converts a file to it&apos;s full file system name
</summary>
</member>
<member name="M:FSharpx.IO.fileSystemInfo(System.String)">
<summary>
 Creates a FileInfo or a DirectoryInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.fileInfo(System.String)">
<summary>
 Creates a FileInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.directoryInfo(System.String)">
<summary>
 Creates a DirectoryInfo for the given path
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.IO">

</member>
<member name="">

</member>
<member name="M:FSharpx.LensModule.listToArray``2(FSharpx.Lens{``0,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Converts a lens that views a list into a lens that views an array
</summary>
</member>
<member name="M:FSharpx.LensModule.xmap``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``0},FSharpx.Lens{``2,``0})">
<summary>
 Applies an isomorphism to the value viewed through a lens
</summary>
</member>
<member name="M:FSharpx.LensModule.seqMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a sequence
</summary>
</member>
<member name="M:FSharpx.LensModule.arrayMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in an array
</summary>
</member>
<member name="M:FSharpx.LensModule.listMap``2(FSharpx.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a list
</summary>
</member>
<member name="M:FSharpx.LensModule.forList``1(System.Int32)">
<summary>
 Lens for a particular position in a list
</summary>
</member>
<member name="M:FSharpx.LensModule.forArray``1(System.Int32)">
<summary>
 Lens for a particular position in an array
</summary>
</member>
<member name="M:FSharpx.LensModule.forMap``2(``0)">
<summary>
 Lens for a particular key in a map
</summary>
</member>
<member name="M:FSharpx.LensModule.forSet``1(``0)">
<summary>
 Lens for a particular value in a set
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.LensModule.id``1">
<summary>
 Identity lens
</summary>
</member>
<member name="M:FSharpx.LensModule.snd``2">
<summary>
 Gets/sets the snd element in a pair
</summary>
</member>
<member name="M:FSharpx.LensModule.fst``2">
<summary>
 Gets/sets the fst element in a pair
</summary>
</member>
<member name="M:FSharpx.LensModule.modifyAndGetState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the modified value.
</summary>
</member>
<member name="M:FSharpx.LensModule.getAndModifyState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the original value.
</summary>
</member>
<member name="M:FSharpx.LensModule.updateState``2(FSharpx.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``1,``1},``0)">
<summary>
 Update through a lens within a state monad
</summary>
</member>
<member name="M:FSharpx.LensModule.setState``2(FSharpx.Lens{``0,``1},``1,``0)">
<summary>
 Applies a lens in the &apos;set&apos; direction within a state monad
</summary>
</member>
<member name="M:FSharpx.LensModule.getState``2(FSharpx.Lens{``0,``1},``0)">
<summary>
 Applies a lens in the &apos;get&apos; direction within a state monad      
</summary>
</member>
<member name="M:FSharpx.LensModule.cond``2(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},FSharpx.Lens{``0,``1},FSharpx.Lens{``0,``1})">
 <summary>
 <paramref name="pred"/> is applied to source. 
 If true, <paramref name="lensTrue"/> is selected.
 If false, <paramref name="lensFalse"/> is selected.
 </summary>
</member>
<member name="M:FSharpx.LensModule.pair``4(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``3})">
<summary>
 Pair two lenses
</summary>
</member>
<member name="M:FSharpx.LensModule.choice``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``1})">
<summary>
 Composes two lenses through a sum in the source
</summary>
</member>
<member name="M:FSharpx.LensModule.compose``3(FSharpx.Lens{``0,``1},FSharpx.Lens{``2,``0})">
<summary>
 Sequentially composes two lenses
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.LensModule.StateOperators">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.LensModule.Operators">

</member>
<member name="T:FSharpx.LensModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.List.cons``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Curried cons
</summary>
</member>
<member name="T:FSharpx.List">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid.OptionMonoid`1">
<summary>
 Option wrapper monoid
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid.ListMonoid`1">
<summary>
 List monoid
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Monoid.Monoid`1.mconcat(System.Collections.Generic.IEnumerable{`0})">
 <summary>
 Fold a list using this monoid
 </summary>
</member>
<member name="M:FSharpx.Monoid.Monoid`1.mappend(`0,`0)">
 <summary>
 Associative operation
 </summary>
</member>
<member name="P:FSharpx.Monoid.Monoid`1.mempty">
 <summary>
 Identity
 </summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Monoid.Monoid`1">
<summary>
 Monoid (associative binary operation with identity)
 The monoid implementation comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/02/01/a-kick-in-the-monads-writer-edition.aspx.
</summary>
</member>
<member name="P:FSharpx.Monoid.IntProductMonoid">
<summary>
 Monoid (int,1,*)
</summary>
</member>
<member name="P:FSharpx.Monoid.IntSumMonoid">
<summary>
 Monoid (int,0,+)
</summary>
</member>
<member name="T:FSharpx.Monoid">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.NameValueCollectionModule.fromSeq(System.Collections.Generic.IEnumerable{System.Tuple`2{System.String,System.String}})">
 <summary>
 Creates a <see cref="NameValueCollection"/> from a list of key-value pairs
 </summary>
 <param name="l"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.toList(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as a list of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.ToEnumerable(System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a <see cref="NameValueCollection"/> as a sequence of key-value pairs.
 Note that keys may be duplicated.
 </summary>
 <param name="a"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.add(System.String,System.String,System.Collections.Specialized.NameValueCollection)">
<summary>
 Adds an element to a copy of an existing NameValueCollection
</summary>
</member>
<member name="M:FSharpx.NameValueCollectionModule.addInPlace(System.Collections.Specialized.NameValueCollection,System.String,System.String)">
 <summary>
 In-place add of a key-value pair to a <see cref="NameValueCollection"/>
 </summary>
 <param name="x"></param>
 <param name="a"></param>
 <param name="b"></param>
</member>
<member name="M:FSharpx.NameValueCollectionModule.Concat(System.Collections.Specialized.NameValueCollection,System.Collections.Specialized.NameValueCollection)">
 <summary>
 Returns a new <see cref="NameValueCollection"/> with the concatenation of two <see cref="NameValueCollection"/>s
 </summary>
 <param name="a"></param>
 <param name="b"></param>
</member>
<member name="T:FSharpx.NameValueCollectionModule">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Nullable">

</member>
<member name="M:FSharpx.Operators.applyM``7(``0,``5,``1,``6)">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Operators">
<summary>
 Generic monadic operators    
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Option.MaybeBuilder">
<summary>
 The maybe monad.
 This monad is my own and uses an &apos;a option. Others generally make their own Maybe&lt;&apos;a&gt; type from Option&lt;&apos;a&gt;.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Option.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpOption{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequentially compose two maybe actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Option.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Option.ap``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Option">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Prelude.tuple6``6(``0,``1,``2,``3,``4,``5)">
<summary>
 Creates a 6-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple5``5(``0,``1,``2,``3,``4)">
<summary>
 Creates a 5-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple4``4(``0,``1,``2,``3)">
<summary>
 Creates a 4-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple3``3(``0,``1,``2)">
<summary>
 Creates a 3-tuple
</summary>
</member>
<member name="M:FSharpx.Prelude.tuple2``2(``0,``1)">
<summary>
 Creates a pair
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Prelude">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader.ReaderBuilder">
<summary>
 The reader monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/07/much-ado-about-monads-reader-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Reader.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``2,Microsoft.FSharp.Core.FSharpFunc`2{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 Sequentially compose two reader actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Reader.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Reader.ap``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``1,``2}},Microsoft.FSharp.Core.FSharpFunc`2{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Reader">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.RegexModule.tryMatchWithOptions(System.Text.RegularExpressions.RegexOptions,System.String,System.String)">
<summary>
flags:RegexOptions -&gt; pattern:string -&gt; input:string -&gt; Regex.ActiveMatch option
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.RegexModule.Interpreted">

</member>
<member name="">

</member>
<member name="T:FSharpx.RegexModule.Compiled">

</member>
<member name="T:FSharpx.RegexModule">

</member>
<member name="">

</member>
<member name="M:FSharpx.Seq.tryFindWithIndex``1(Microsoft.FSharp.Core.FSharpFunc`2{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Returns the first element (with its index) for which the given function returns true.
 Return None if no such element exists.
 </summary>
 <param name="pred">Predicate</param>
 <param name="l">Sequence</param>
</member>
<member name="M:FSharpx.Seq.index``1(System.Collections.Generic.IEnumerable{``0})">
 <summary>
 Adds an index to a sequence
 </summary>
 <param name="a"></param>
</member>
<member name="T:FSharpx.Seq">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State.StateBuilder">
<summary>
 The state monad.
 The algorithm is adjusted from my original work off of Brian Beckman&apos;s http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/.
 The approach was adjusted from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2009/12/30/much-ado-about-monads-state-edition.aspx and mirrors his final result.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.State.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``1,``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``3,``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.State.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.State.ap``3(Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{``0,``1}},Microsoft.FSharp.Core.FSharpFunc`2{``1,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``2},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},``2}},Microsoft.FSharp.Core.FSharpFunc`2{``2,System.Tuple`2{``0,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.State">

</member>
<member name="M:FSharpx.Strings.isNullOrEmpty(System.String)">
<summary>
 Returns if the string is null or empty
</summary>
</member>
<member name="M:FSharpx.Strings.separatedBy(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings to a single string separated with the delimiters
</summary>
</member>
<member name="M:FSharpx.Strings.split(System.Char,System.String)">
<summary>
 Splits the given string at the given delimiter
</summary>
</member>
<member name="M:FSharpx.Strings.contains(System.String,System.String)">
<summary>
 Returns a value indicating whether the specified substring occurs within this string
</summary>
</member>
<member name="M:FSharpx.Strings.replace(System.String,System.String,System.String)">
<summary>
 Replaces the given &quot;replacement&quot; for every occurence of the pattern in the given text 
</summary>
</member>
<member name="M:FSharpx.Strings.startsWith(System.String,System.String)">
<summary>
 Checks whether the given text starts with the given prefix
</summary>
</member>
<member name="T:FSharpx.Strings">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Undo">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apr``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apl``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.ap``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.op_LessMultiply``2">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.op_MultiplyGreater``2">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}},Microsoft.FSharp.Core.FSharpChoice{``0,Microsoft.FSharp.Collections.FSharpList{System.String}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.ap``2">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.Validation.apm``3(FSharpx.Monoid.Monoid{``0})">
<summary>
 Sequential application, parameterized by monoid
</summary>
</member>
<member name="M:FSharpx.Validation.apa``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{``0,``0}},Microsoft.FSharp.Core.FSharpChoice{``1,``0},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc`2{``1,``2},``0})">
<summary>
 Sequential application, parameterized by append
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.Validation">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Writer.WriterBuilder`1">
<summary>
 The writer monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/02/01/a-kick-in-the-monads-writer-edition.aspx.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc`2{``0,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc`2{``1,Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``2,Microsoft.FSharp.Collections.FSharpList{System.String}}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Writer.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:FSharpx.Writer.ap``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc`2{Microsoft.FSharp.Core.Unit,System.Tuple`2{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:FSharpx.Writer">

</member>
<member name="M:FSharpx.ZipList.op_LessMultiply``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.op_MultiplyGreater``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="">

</member>
<member name="M:FSharpx.ZipList.ap``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ZipList.op_LessMultiplyGreater``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc`2{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="">

</member>
<member name="T:FSharpx.ZipList">

</member>
</members>
</doc>
